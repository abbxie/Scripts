--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

local punchRemote = ReplicatedStorage:WaitForChild("Events", 9e9):WaitForChild("PunchBlock", 9e9)

--// Rayfield Setup
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({Name = "Block Highlighter & Puncher", LoadingTitle = "Block Tools", LoadingSubtitle = "by You", Theme = "Default"})
local Tab = Window:CreateTab("Main", 4483362458)

--// Block Containers
local worldBlocks = workspace:WaitForChild("WorldBlocks")
local worldBackgrounds = workspace:WaitForChild("WorldBackgrounds")
local function getAllBlockGroups()
    local all = {}
    for _, v in ipairs(worldBlocks:GetChildren()) do table.insert(all, v) end
    for _, v in ipairs(worldBackgrounds:GetChildren()) do table.insert(all, v) end
    return all
end

--// Settings
local DOT_THRESHOLD = 0.5
local Y_THRESHOLD = 2
local ALLOWED_BLOCKS = {}

--// Direction state
local directionState = {Up=false, Down=false, Left=false, Right=false}
local function setDirection(dir, state)
    for k in pairs(directionState) do directionState[k] = false end
    directionState[dir] = state
end

--// Normalize helper
local function normalize(s) if not s then return "" end return tostring(s):gsub("^%s*(.-)%s*$","%1"):lower() end
local function isAllowedBlockByModelName(modelName)
    local n = normalize(modelName)
    for _, allowed in ipairs(ALLOWED_BLOCKS) do
        if n == allowed then return true end
        if n:find(allowed,1,true) then return true end
    end
    return false
end

--// Direction filters
local function passesDirectionFilters(part)
    if not part then return false end
    local pos = part.Position
    local rootPos = root.Position
    local dirVec = (pos - rootPos)
    if dirVec.Magnitude == 0 then return false end

    if directionState.Up then return pos.Y > rootPos.Y + Y_THRESHOLD end
    if directionState.Down then return pos.Y < rootPos.Y - Y_THRESHOLD end
    if directionState.Left then
        -- Blocktopia Left = +X
        return (Vector3.new(pos.X - rootPos.X,0,0).Unit):Dot(Vector3.new(1,0,0)) > 0.5
    end
    if directionState.Right then
        -- Blocktopia Right = -X (fixed)
        return (Vector3.new(pos.X - rootPos.X,0,0).Unit):Dot(Vector3.new(-1,0,0)) > 0.5
    end
    return false
end

local function getDirectionVector()
    if directionState.Up then return Vector3.new(0,1,0)
    elseif directionState.Down then return Vector3.new(0,-1,0)
    elseif directionState.Left then return Vector3.new(1,0,0) -- Blocktopia left
    elseif directionState.Right then return Vector3.new(-1,0,0) -- Blocktopia right
    end
end

--// Highlights
local breakerHighlight = Instance.new("SelectionBox", game.CoreGui)
breakerHighlight.LineThickness = 0.05
breakerHighlight.SurfaceTransparency = 0.5
breakerHighlight.Color3 = Color3.fromRGB(255,0,0)

local nextHighlight = Instance.new("SelectionBox", game.CoreGui)
nextHighlight.LineThickness = 0.05
nextHighlight.SurfaceTransparency = 0.5
nextHighlight.Color3 = Color3.fromRGB(0,0,255)

local doorHighlight = Instance.new("SelectionBox", game.CoreGui)
doorHighlight.LineThickness = 0.05
doorHighlight.SurfaceTransparency = 0.5
doorHighlight.Color3 = Color3.fromRGB(0,255,0)

-- Thin red line for direction
local redLine = Instance.new("Part", game.CoreGui)
redLine.Anchored = true
redLine.CanCollide = false
redLine.Size = Vector3.new(0.1,0.1,10)
redLine.Color = Color3.fromRGB(255,0,0)
redLine.Material = Enum.Material.Neon

--// Whitelist GUI (separate from Rayfield)
local ScreenGui = Instance.new("ScreenGui", game.CoreGui)
ScreenGui.Name = "WhitelistGui"
local BoxFrame = Instance.new("Frame", ScreenGui)
BoxFrame.Size = UDim2.new(0,300,0,60)
BoxFrame.Position = UDim2.new(0,100,0,100)
BoxFrame.BackgroundColor3 = Color3.fromRGB(30,30,30)
BoxFrame.Active = true
BoxFrame.Draggable = true

local TextBox = Instance.new("TextBox", BoxFrame)
TextBox.Size = UDim2.new(1,-10,0,40)
TextBox.Position = UDim2.new(0,5,0,10)
TextBox.PlaceholderText = "Enter block names (comma-separated)"
TextBox.Text = ""
TextBox.ClearTextOnFocus = false
TextBox.FocusLost:Connect(function()
    ALLOWED_BLOCKS = {}
    for blockName in string.gmatch(TextBox.Text,'([^,]+)') do
        local clean = blockName:match("^%s*(.-)%s*$")
        table.insert(ALLOWED_BLOCKS,normalize(clean))
    end
    print("Whitelist updated:", unpack(ALLOWED_BLOCKS))
end)

--// Rayfield Toggles
Tab:CreateToggle({Name="Punch Up", CurrentValue=false, Flag="PunchUp", Callback=function(Value) setDirection("Up",Value) end})
Tab:CreateToggle({Name="Punch Down", CurrentValue=false, Flag="PunchDown", Callback=function(Value) setDirection("Down",Value) end})
Tab:CreateToggle({Name="Punch Left", CurrentValue=false, Flag="PunchLeft", Callback=function(Value) setDirection("Left",Value) end})
Tab:CreateToggle({Name="Punch Right", CurrentValue=false, Flag="PunchRight", Callback=function(Value) setDirection("Right",Value) end})

--// Red line update
RunService.RenderStepped:Connect(function()
    local dirVec = getDirectionVector()
    if dirVec then
        local startPos = root.Position + dirVec*2.5
        local endPos = root.Position + dirVec*5
        redLine.CFrame = CFrame.new((startPos+endPos)/2, endPos)
        redLine.Size = Vector3.new(0.1,0.1,(endPos-startPos).Magnitude)
        redLine.Transparency = 0
    else
        redLine.Transparency = 1
    end
end)

--// Auto Breaker Loop
task.spawn(function()
    while true do
        local dirVec = getDirectionVector()
        if dirVec then
            local inDirBlocks = {}
            for _, model in ipairs(getAllBlockGroups()) do
                local part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                if part and passesDirectionFilters(part) and isAllowedBlockByModelName(model.Name) then
                    local dirToBlock = (part.Position - root.Position).Unit
                    if dirToBlock:Dot(dirVec) > 0.9 then
                        table.insert(inDirBlocks,{model=model,part=part,dist=(part.Position - root.Position).Magnitude})
                    end
                end
            end
            table.sort(inDirBlocks,function(a,b) return a.dist<b.dist end)

            local redPart, redModel = nil,nil
            local bluePart, blueModel = nil,nil

            if #inDirBlocks>=1 then
                redModel = inDirBlocks[1].model
                redPart = inDirBlocks[1].part
            end
            for i=2,#inDirBlocks do
                local block = inDirBlocks[i]
                local dirToBlock = (block.part.Position - redPart.Position).Unit
                if dirToBlock:Dot(dirVec) > 0.9 then
                    blueModel = block.model
                    bluePart = block.part
                    break
                end
            end

            breakerHighlight.Adornee = redPart
            nextHighlight.Adornee = bluePart

            if redModel and redModel:IsDescendantOf(workspace) then
                local children = getAllBlockGroups()
                local idx = table.find(children, redModel)
                if idx then pcall(function() punchRemote:FireServer(children[idx]) end) end
            else
                breakerHighlight.Adornee = nil
                nextHighlight.Adornee = nil
            end
        else
            breakerHighlight.Adornee = nil
            nextHighlight.Adornee = nil
        end
        task.wait(0.05)
    end
end)

--// Auto Door
local autoDoorRunning = false
Tab:CreateToggle({Name="Auto Door Enter", CurrentValue=false, Flag="AutoDoor", Callback=function(Value)
    autoDoorRunning = Value
    if Value then
        task.spawn(function()
            while autoDoorRunning do
                local lookVector = root.CFrame.LookVector
                local behindDir = -lookVector
                local params = RaycastParams.new()
                params.FilterDescendantsInstances = {character}
                params.FilterType = Enum.RaycastFilterType.Blacklist
                local result = workspace:Raycast(root.Position, behindDir*20, params)
                if result and result.Instance then
                    local hit = result.Instance
                    if hit.Name=="Door" or hit.Name=="HurtBox" then
                        local parentBlock = hit.Name=="Door" and hit or hit.Parent
                        if parentBlock and parentBlock:IsDescendantOf(workspace) then
                            task.wait(1)
                            local children = getAllBlockGroups()
                            local blockIndex = table.find(children, parentBlock)
                            if blockIndex then
                                punchRemote:FireServer(children[blockIndex])
                                doorHighlight.Adornee = parentBlock
                            end
                        end
                    else
                        doorHighlight.Adornee = nil
                    end
                else
                    doorHighlight.Adornee = nil
                end
                task.wait(0.5)
            end
            doorHighlight.Adornee = nil
        end)
    else
        doorHighlight.Adornee = nil
    end
end})
