local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local root = character:WaitForChild("HumanoidRootPart")

local worldBlocks = workspace:WaitForChild("WorldBlocks")

-- how many blocks to scan downward
local SCAN_DEPTH = 2
-- assuming blocks are size 3 (like Blocktopia grid)
local BLOCK_SIZE = 3

-- store highlights so we donâ€™t remake them every loop
local highlights = {}

local function makeHighlight(part)
    local box = Instance.new("SelectionBox")
    box.LineThickness = 0.02
    box.SurfaceTransparency = 0.5
    box.Color3 = Color3.fromRGB(255, 255, 255) -- white
    box.Adornee = part
    box.Parent = game.CoreGui
    return box
end

-- function to check block below
local function getBlockBelow(offset)
    local pos = root.Position - Vector3.new(0, offset * BLOCK_SIZE, 0)
    local closestBlock = nil
    local shortestDist = math.huge

    for _, block in ipairs(worldBlocks:GetChildren()) do
        for _, child in ipairs(block:GetChildren()) do
            if child:IsA("BasePart") then
                local dist = (child.Position - pos).Magnitude
                if dist < shortestDist then
                    shortestDist = dist
                    closestBlock = child
                end
            end
        end
    end

    return closestBlock
end

-- scan loop
while task.wait(0.5) do
    -- clear old highlights
    for _, h in ipairs(highlights) do
        h:Destroy()
    end
    highlights = {}

    for i = 1, SCAN_DEPTH do
        local block = getBlockBelow(i)
        if block then
            -- make a white highlight
            local h = makeHighlight(block)
            table.insert(highlights, h)

            -- debug info
            print("Scanning:", block.Name, " | Parent:", block.Parent.Name)

            -- door check (block itself or parent or child named "Door")
            if block.Name == "Door" or block.Parent.Name == "Door" or block:FindFirstChild("Door") then
                print("door")
            end
        end
    end
end
